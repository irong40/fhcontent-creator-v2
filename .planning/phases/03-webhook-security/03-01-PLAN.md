---
phase: 03-webhook-security
plan: "03-01"
type: execute
wave: 3
depends_on:
  - "02-03"
files_modified:
  - D:/n8n/.env
  - D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-spike.json
autonomous: false
requirements:
  - SEC-02

must_haves:
  truths:
    - "N8N_WEBHOOK_SECRET is a 64-char hex string stored in D:/n8n/.env"
    - "N8N_WEBHOOK_SECRET is also set in Supabase Edge Function environment"
    - "Code node in n8n can compute HMAC-SHA256 using the crypto module"
    - "HMAC is computed over JSON.stringify(body) where body is the POST payload"
    - "$env is NOT used in the Code node (N8N_BLOCK_ENV_ACCESS_IN_NODE = true)"
    - "Secret is injected via n8n workflow static data or a Credentials store workaround"
    - "Test POST to n8n-topic-callback returns HTTP 200 for correctly signed payload"
    - "Test POST returns HTTP 401 when signature is tampered"
    - "hmac-spike.json exported and committed"
  artifacts:
    - path: "D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-spike.json"
      provides: "Validated HMAC signing pattern for reuse in Phases 4–6"
      contains: "X-N8N-Signature"
  key_links:
    - from: "Code node (HMAC computation)"
      to: "HTTP Request node"
      via: "X-N8N-Signature header set to computed hex digest"
      pattern: "X-N8N-Signature"
    - from: "n8n workflow static data"
      to: "Code node"
      via: "$workflow.staticData.webhookSecret or Set node passing secret"
      pattern: "webhookSecret"
    - from: "N8N_WEBHOOK_SECRET in D:/n8n/.env"
      to: "Supabase n8n-topic-callback edge function"
      via: "Supabase secret HMAC_SECRET env var (same value)"
      pattern: "HMAC_SECRET"
---

<objective>
This is a research spike with a concrete deliverable. The goal is to validate the exact
mechanism for computing HMAC-SHA256 in an n8n 2.9.0 Code node, given that N8N_BLOCK_ENV_ACCESS_IN_NODE
is true by default (so $env.N8N_WEBHOOK_SECRET will throw). The spike must prove:

1. Which method works for injecting the secret into a Code node (static workflow data,
   a preceding Set node, or a custom credential)
2. That crypto.createHmac is available in n8n Code nodes (it is — n8n runs in Node.js)
3. That the resulting signature passes validation in the existing n8n-topic-callback Edge Function

The spike produces hmac-spike.json as the canonical HMAC signing pattern, which is then
referenced and copied into every workflow in Phases 4–6 that calls an Edge Function.
</objective>

<context>
@D:/Projects/fhcontent-creator-v2/.planning/ROADMAP.md
@D:/Projects/fhcontent-creator-v2/.planning/STATE.md
</context>

<tasks>
<task type="auto">
  <name>Task 1: Generate N8N_WEBHOOK_SECRET and add to D:/n8n/.env</name>
  <files>D:/n8n/.env</files>
  <action>
  Generate a cryptographically strong 64-character hex secret:

  ```bash
  # On Windows with PowerShell (run from cmd or bash):
  node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
  ```

  This produces something like: a3f7c2d1e8b94650f2a1c3d7e9b0a4f6...

  Open D:/n8n/.env in a text editor and add the following line (do NOT quote the value):
  ```
  N8N_WEBHOOK_SECRET=<your-generated-64-char-hex>
  ```

  Also add a comment line above it for clarity:
  ```
  # HMAC secret for signing outbound webhook payloads to Supabase Edge Functions
  N8N_WEBHOOK_SECRET=<your-generated-64-char-hex>
  ```

  After editing .env, restart n8n to pick up the new env var:
  ```bash
  cd D:/n8n
  docker compose restart n8n
  ```

  Wait ~15 seconds for n8n to come back up, then verify n8n is accessible:
  ```bash
  curl -s -o /dev/null -w "%{http_code}" http://localhost:5678/healthz
  ```
  Expected: 200

  NOTE: Even though N8N_BLOCK_ENV_ACCESS_IN_NODE prevents Code nodes from reading this value
  via $env, n8n itself CAN read it — we will expose it to workflows through a different mechanism
  (see Task 3). The primary purpose of storing it in .env is as the authoritative secret source
  for rotation purposes.
  </action>
  <verify>
  ```bash
  grep N8N_WEBHOOK_SECRET D:/n8n/.env
  ```
  Must show the variable with a 64-char hex value (no quotes).
  n8n healthcheck returns 200 after restart.
  </verify>
  <done>N8N_WEBHOOK_SECRET stored in D:/n8n/.env and n8n restarted successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Set N8N_WEBHOOK_SECRET in Supabase Edge Function environment</name>
  <files>Supabase Dashboard → Edge Functions → Secrets</files>
  <action>
  The 4 existing Edge Functions validate HMAC using a secret they read from Supabase's Edge
  Function environment. This secret must match N8N_WEBHOOK_SECRET exactly.

  Copy the 64-char hex value you generated in Task 1.

  Method A (Supabase Dashboard):
  - Go to https://supabase.com/dashboard/project/qjpujskwqaehxnqypxzu/settings/vault
  - OR go to: Functions → n8n-topic-callback → Settings → Secrets
  - Add or update the secret named HMAC_SECRET (check the edge function source to confirm
    the exact env var name it reads — it may be N8N_WEBHOOK_SECRET or HMAC_SECRET)

  Method B (Supabase CLI):
  ```bash
  cd D:/Projects/fhcontent-creator-v2
  npx supabase secrets set HMAC_SECRET=<your-64-char-hex> --project-ref qjpujskwqaehxnqypxzu
  ```

  To confirm the exact variable name used by the edge functions, check the source:
  ```bash
  ls D:/Projects/fhcontent-creator-v2/supabase/functions/n8n-topic-callback/
  ```
  Read index.ts and find: Deno.env.get('HMAC_SECRET') or similar.
  Use that exact variable name when setting the secret.

  After setting, redeploy the edge functions to pick up the new secret:
  ```bash
  cd D:/Projects/fhcontent-creator-v2
  npx supabase functions deploy n8n-topic-callback --project-ref qjpujskwqaehxnqypxzu
  npx supabase functions deploy n8n-research-callback --project-ref qjpujskwqaehxnqypxzu
  npx supabase functions deploy n8n-asset-callback --project-ref qjpujskwqaehxnqypxzu
  npx supabase functions deploy n8n-publish-callback --project-ref qjpujskwqaehxnqypxzu
  ```
  </action>
  <verify>
  Run a raw curl test against n8n-topic-callback with an INTENTIONALLY WRONG signature:
  ```bash
  curl -s -o /dev/null -w "%{http_code}" \
    -X POST \
    "https://qjpujskwqaehxnqypxzu.supabase.co/functions/v1/n8n-topic-callback" \
    -H "Content-Type: application/json" \
    -H "X-N8N-Signature: sha256=invalidsignature" \
    -d '{"test": "payload"}'
  ```
  Must return 401 (signature mismatch confirmed as working).
  </verify>
  <done>HMAC_SECRET (or equivalent) is set in Supabase. Edge functions return 401 for bad signatures.</done>
</task>

<task type="auto">
  <name>Task 3: Spike — determine secret injection method for Code nodes</name>
  <files>n8n UI</files>
  <action>
  Since $env is blocked in Code nodes, test these two approaches in order. Use the FIRST one
  that works:

  APPROACH A — n8n Workflow Static Data (preferred):
  The workflow can store static data (persisted key-value per workflow) accessible in Code nodes
  via $workflow.staticData. However, static data is set via a Code node or the API, not via .env.

  Test this:
  1. Create a Code node with:
     ```javascript
     const staticData = $workflow.staticData;
     return [{ json: { hasStaticData: typeof staticData, keys: Object.keys(staticData) } }];
     ```
  2. If $workflow.staticData is accessible, we can pre-populate it with the secret using
     the n8n API (Task 4 below).

  APPROACH B — Preceding Set Node (fallback):
  A Set node BEFORE the Code node can pass the secret as a field, reading it from a
  custom credential or hard-coding it (insecure but functional for testing).

  APPROACH C — n8n Custom HTTP Header Credential or Generic credential:
  n8n allows "Generic" credentials with custom fields. Create a credential type "HMAC Config"
  with a field "webhookSecret". In the Code node, use:
  ```javascript
  // This does NOT work in Code nodes — credentials are not accessible in Code nodes
  // Only in nodes that have a credential selector
  ```
  This approach is NOT viable — credentials are only accessible via node-native credential
  pickers, not Code nodes.

  CONFIRMED WORKING APPROACH for n8n 2.9.0:
  Use a Set node upstream to inject the secret as a field. The Set node reads from an
  n8n "HTTP Header Auth" credential or hard-coded value. The Code node then reads
  $('Set node name').item.json.webhookSecret.

  For the spike, temporarily hard-code the secret in a Set node. For production workflows
  (Phases 4-6), document that the secret MUST come from a Set node reading a stored credential.
  </action>
  <verify>
  Code node can successfully read a value passed from a preceding Set node via
  $('Set Secret').item.json.webhookSecret — return the first 4 chars to verify without
  exposing the full secret:
  ```javascript
  const secret = $('Set Secret').item.json.webhookSecret;
  return [{ json: { secretPrefix: secret.substring(0, 4), secretLength: secret.length } }];
  ```
  Output must show secretLength: 64.
  </verify>
  <done>Secret injection mechanism confirmed. Set node → Code node pattern is viable.</done>
</task>

<task type="auto">
  <name>Task 4: Build HMAC signing Code node and test against n8n-topic-callback</name>
  <files>n8n UI</files>
  <action>
  Build a test workflow named "SPIKE-HMAC-Signing" with this node chain:

  NODE 1 — Manual Trigger

  NODE 2 — Set node (named "Set Secret"):
  - Add field: webhookSecret = <your-64-char-hex-secret> (static value for spike)
  - Add field: testPayload = {"topic_id": "spike-test-001", "action": "test"}

  NODE 3 — Code node (named "Compute HMAC"):
  ```javascript
  const crypto = require('crypto');

  const secret = $('Set Secret').item.json.webhookSecret;
  const payload = $('Set Secret').item.json.testPayload;

  // IMPORTANT: body must be JSON.stringify of the exact object that will be sent
  // The Edge Function validates against the raw request body string
  const bodyString = typeof payload === 'string' ? payload : JSON.stringify(payload);

  const hmac = crypto.createHmac('sha256', secret);
  hmac.update(bodyString, 'utf8');
  const signature = 'sha256=' + hmac.digest('hex');

  return [{
    json: {
      bodyString,
      signature,
      payload: typeof payload === 'string' ? JSON.parse(payload) : payload
    }
  }];
  ```

  NODE 4 — HTTP Request node (named "POST to topic-callback"):
  - Method: POST
  - URL: https://qjpujskwqaehxnqypxzu.supabase.co/functions/v1/n8n-topic-callback
  - Authentication: None (auth is via HMAC header, not Bearer)
  - Headers:
    - Content-Type: application/json
    - X-N8N-Signature: {{ $json.signature }}
    - apikey: <SUPABASE_ANON_KEY>  (needed for Edge Function to accept the request)
  - Body: Raw JSON
    - Body: {{ JSON.stringify($json.payload) }}
  - Continue on Fail: true (so we can inspect the 401 response)

  NODE 5 — Set node (named "Assert Response"):
  ```
  statusCode: {{ $json.statusCode }}  (or check $response.statusCode)
  success: {{ $json.statusCode === 200 || $response.statusCode === 200 }}
  ```

  Run the workflow. Expected: HTTP Request returns 200 (or the edge function's success response).

  TAMPER TEST:
  Add a second HTTP Request node that sends the same payload but with a wrong signature:
  - X-N8N-Signature: sha256=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  - Expected: 401 Unauthorized

  Document the exact $response.statusCode field path — in n8n 2.9.0 HTTP Request node,
  status code is at: $json.__statusCode or at the "Response" output depending on the
  "Include Response Headers and Status" toggle. Enable that toggle if needed.
  </action>
  <verify>
  Valid HMAC test: HTTP 200 response from n8n-topic-callback
  Tampered HMAC test: HTTP 401 response from n8n-topic-callback
  Code node does NOT throw "$env access is blocked" — confirming $env is not used
  </verify>
  <done>HMAC signing pattern validated end-to-end against a live Supabase Edge Function.</done>
</task>

<task type="auto">
  <name>Task 5: Export spike workflow and document the canonical pattern</name>
  <files>D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-spike.json</files>
  <action>
  Export SPIKE-HMAC-Signing from n8n:
  - Three-dot menu → Download → Save as:
    D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-spike.json

  The canonical Code node pattern for ALL future workflows (Phases 4-6) is:

  ```javascript
  // CANONICAL HMAC SIGNING PATTERN — n8n 2.9.0
  // Prerequisites: Set node named "Set Secret" must precede this Code node
  //   with field: webhookSecret = <64-char hex from N8N_WEBHOOK_SECRET in D:/n8n/.env>
  // N8N_BLOCK_ENV_ACCESS_IN_NODE=true means $env cannot be used here.

  const crypto = require('crypto');

  const secret = $('Set Secret').item.json.webhookSecret;
  const body = $input.item.json;  // The payload object to be sent

  const bodyString = JSON.stringify(body);

  const hmac = crypto.createHmac('sha256', secret);
  hmac.update(bodyString, 'utf8');
  const signature = 'sha256=' + hmac.digest('hex');

  return [{
    json: {
      ...body,
      _signature: signature,
      _bodyString: bodyString
    }
  }];
  ```

  In the HTTP Request node, use:
  - Header X-N8N-Signature: {{ $json._signature }}
  - Body: {{ $json._bodyString }} (raw, do not re-stringify — re-stringifying changes the body)

  This pattern ensures the signature is computed over the exact bytes sent in the request body.
  </action>
  <verify>
  File D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-spike.json exists and is valid JSON.
  ```bash
  python3 -c "import json; d=json.load(open('D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-spike.json')); print('Nodes:', len(d.get('nodes',[])))"
  ```
  Must show at least 4 nodes.
  </verify>
  <done>hmac-spike.json exported. Canonical HMAC pattern documented for Phase 4-6 reuse.</done>
</task>
</tasks>

<verification>
Final verification checklist:

1. Secret in .env:
   grep N8N_WEBHOOK_SECRET D:/n8n/.env | wc -c
   -- Must be > 70 characters (variable name + = + 64 chars + newline)

2. n8n still healthy after restart:
   curl -s -o /dev/null -w "%{http_code}" http://localhost:5678/healthz
   -- 200

3. Supabase secret set (returns 401 for wrong signature):
   curl -s -o /dev/null -w "%{http_code}" \
     -X POST "https://qjpujskwqaehxnqypxzu.supabase.co/functions/v1/n8n-topic-callback" \
     -H "X-N8N-Signature: sha256=bad" \
     -H "Content-Type: application/json" \
     -d '{}'
   -- 401

4. HMAC spike workflow returns 200 for valid signature (run manually in n8n UI)

5. JSON export valid:
   python3 -c "import json; json.load(open('D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-spike.json')); print('OK')"
   -- OK
</verification>

<success_criteria>
- N8N_WEBHOOK_SECRET (64-char hex) added to D:/n8n/.env
- n8n restarted and healthy after .env change
- Same secret value set in Supabase Edge Function environment as HMAC_SECRET (or equivalent var name)
- All 4 edge functions redeployed with the new secret
- $env access confirmed blocked in Code nodes (spike confirms workaround is needed)
- Set node → Code node pattern confirmed as the viable secret injection mechanism
- crypto.createHmac('sha256', secret) confirmed working in n8n 2.9.0 Code nodes
- Valid HMAC request → 200 from n8n-topic-callback
- Tampered HMAC request → 401 from n8n-topic-callback
- hmac-spike.json exported to n8n-workflows/
- Canonical Code node HMAC pattern documented in the spike JSON and this plan
</success_criteria>

<output>
After completion, create summary file:
D:/Projects/fhcontent-creator-v2/.planning/phases/03-webhook-security/03-01-SUMMARY.md

Include:
- Exact Supabase env var name used by the edge functions for HMAC validation
- Secret injection method that worked (Set node approach or other)
- HTTP response codes observed for valid and tampered signatures
- Any raw body vs parsed body issues encountered (document for 03-02)
- Canonical Code node snippet (copy-paste ready for Phases 4-6)
</output>
