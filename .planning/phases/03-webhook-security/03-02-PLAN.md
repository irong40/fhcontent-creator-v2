---
phase: 03-webhook-security
plan: "03-02"
type: execute
wave: 3
depends_on:
  - "03-01"
files_modified:
  - D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json
autonomous: false
requirements:
  - SEC-03
  - INT-02

must_haves:
  truths:
    - "All 4 edge functions return HTTP 200 for correctly signed payloads"
    - "All 4 edge functions return HTTP 401 for tampered body or wrong signature"
    - "HTTP 401 test uses correct body but wrong signature (not missing header)"
    - "HTTP 401 test uses correct signature but mutated body (confirms body binding)"
    - "HMAC Code node pattern from 03-01 is reused without modification"
    - "hmac-test.json exported with all 4 positive and 4 negative test cases"
    - "Results are documented in 03-02-SUMMARY.md before Phase 4 begins"
  artifacts:
    - path: "D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json"
      provides: "End-to-end HMAC validation test suite for all 4 edge functions"
      contains: "n8n-topic-callback"
  key_links:
    - from: "hmac-test workflow"
      to: "n8n-topic-callback"
      via: "POST with X-N8N-Signature header"
      pattern: "n8n-topic-callback"
    - from: "hmac-test workflow"
      to: "n8n-research-callback"
      via: "POST with X-N8N-Signature header"
      pattern: "n8n-research-callback"
    - from: "hmac-test workflow"
      to: "n8n-asset-callback"
      via: "POST with X-N8N-Signature header"
      pattern: "n8n-asset-callback"
    - from: "hmac-test workflow"
      to: "n8n-publish-callback"
      via: "POST with X-N8N-Signature header"
      pattern: "n8n-publish-callback"
---

<objective>
Extend the HMAC spike from 03-01 into a comprehensive test workflow that validates HMAC signing
against all 4 existing Supabase Edge Functions. For each function, the test sends both a valid
(correctly signed) request and an invalid (tampered) request, asserting the expected HTTP response
codes. This confirms that the HMAC secret is correctly set across all 4 functions and that the
canonical signing pattern from 03-01 is reusable as-is. The exported hmac-test.json becomes the
regression test for HMAC security — re-run it after any secret rotation or edge function deployment.
</objective>

<context>
@D:/Projects/fhcontent-creator-v2/.planning/ROADMAP.md
@D:/Projects/fhcontent-creator-v2/.planning/STATE.md
</context>

<tasks>
<task type="auto">
  <name>Task 1: Inspect all 4 edge function sources for expected payload shape</name>
  <files>D:/Projects/fhcontent-creator-v2/supabase/functions/</files>
  <action>
  Before building the test workflow, read each edge function's index.ts to understand:
  1. What payload fields are required (to avoid 400 errors that look like 401s)
  2. Exact env var name used for HMAC validation (should be the same across all 4)
  3. Whether each function validates HMAC before or after parsing the body

  Read the following files:
  - D:/Projects/fhcontent-creator-v2/supabase/functions/n8n-topic-callback/index.ts
  - D:/Projects/fhcontent-creator-v2/supabase/functions/n8n-research-callback/index.ts
  - D:/Projects/fhcontent-creator-v2/supabase/functions/n8n-asset-callback/index.ts
  - D:/Projects/fhcontent-creator-v2/supabase/functions/n8n-publish-callback/index.ts

  For each function, note:
  - HMAC env var name (e.g., HMAC_SECRET, N8N_WEBHOOK_SECRET, WEBHOOK_SECRET)
  - HMAC validation happens: before body parsing (good) or after (risky)
  - Minimum required payload fields to reach the HMAC validation step without a 400 error

  IMPORTANT: The test payloads for the VALID signature tests must be structurally valid
  enough that the function at least reaches the signature check. If the function returns 400
  (bad request) before checking the signature, the test is inconclusive.

  Typical minimum payload per function (adjust based on source inspection):
  - n8n-topic-callback:   {"topic_id": "test-uuid", "action": "research_complete"}
  - n8n-research-callback: {"topic_id": "test-uuid", "research_status": "complete"}
  - n8n-asset-callback:   {"topic_id": "test-uuid", "asset_type": "image"}
  - n8n-publish-callback: {"topic_id": "test-uuid", "platform": "twitter"}
  </action>
  <verify>
  You have noted the HMAC env var name and minimum payload for each of the 4 functions.
  If all 4 use the same env var name, document that. If they differ, note each one.
  </verify>
  <done>Edge function payload requirements documented. Ready to build test workflow.</done>
</task>

<task type="auto">
  <name>Task 2: Build HMAC-Test workflow covering all 4 edge functions</name>
  <files>n8n UI</files>
  <action>
  Create a new workflow named "HMAC-Test-All-Functions" in n8n.

  This workflow uses a BRANCH pattern: one Set Secret node feeds into 4 parallel test chains
  (one per edge function). Each chain has a valid-signature test and a tampered-signature test.

  GLOBAL SETUP NODES:

  NODE 1 — Manual Trigger

  NODE 2 — Set node (named "Set Secret and Base URL"):
  - webhookSecret: <64-char hex from N8N_WEBHOOK_SECRET in D:/n8n/.env>
  - supabaseBaseUrl: https://qjpujskwqaehxnqypxzu.supabase.co/functions/v1
  - supabaseAnonKey: <SUPABASE_ANON_KEY from project settings>

  ---
  CHAIN 1: n8n-topic-callback

  NODE 3 — Set node (named "Payload-Topic"):
  - topic_id: test-topic-hmac-001
  - action: research_complete
  - Connect from: Set Secret and Base URL

  NODE 4 — Code node (named "Sign-Topic"):
  Use the canonical pattern from 03-01:
  ```javascript
  const crypto = require('crypto');
  const secret = $('Set Secret and Base URL').item.json.webhookSecret;
  const body = $input.item.json;
  const bodyString = JSON.stringify(body);
  const hmac = crypto.createHmac('sha256', secret);
  hmac.update(bodyString, 'utf8');
  const signature = 'sha256=' + hmac.digest('hex');
  return [{ json: { ...body, _signature: signature, _bodyString: bodyString } }];
  ```

  NODE 5 — HTTP Request (named "Test-Topic-Valid"):
  - Method: POST
  - URL: {{ $('Set Secret and Base URL').item.json.supabaseBaseUrl }}/n8n-topic-callback
  - Headers:
    - Content-Type: application/json
    - X-N8N-Signature: {{ $json._signature }}
    - apikey: {{ $('Set Secret and Base URL').item.json.supabaseAnonKey }}
  - Body: {{ $json._bodyString }}
  - Response Format: Include Response Headers and Status = true
  - Continue on Fail: true

  NODE 6 — HTTP Request (named "Test-Topic-Tampered"):
  - Same as NODE 5 but:
    - X-N8N-Signature: sha256=0000000000000000000000000000000000000000000000000000000000000000
  - Continue on Fail: true

  ---
  CHAINS 2, 3, 4: Repeat the same 4-node pattern for:
  - n8n-research-callback (nodes 7–10)
  - n8n-asset-callback (nodes 11–14)
  - n8n-publish-callback (nodes 15–18)

  Use the appropriate minimum payload from Task 1 for each chain.
  Connect each chain's Set Payload node FROM "Set Secret and Base URL" (parallel branching).

  ---
  FINAL NODE — Set node (named "Collect Results"):
  - Manually connected after all 8 HTTP Request nodes (or just after the last chain)
  - For a simpler layout, connect only the last chain's tampered test here
  - This node summarizes: log a message "All 4 functions tested"

  NOTE on workflow layout: n8n does not have a native "parallel join" for 4 chains.
  The simplest approach is to run the chains sequentially (each chain feeds into the next
  via a connecting edge from the last node of chain N to the first payload node of chain N+1).
  This avoids complex merge logic while still testing all 4 functions in a single execution.

  Sequential layout:
  Manual Trigger → Set Secret → Payload-Topic → Sign-Topic → Test-Topic-Valid → Test-Topic-Tampered
  → Payload-Research → Sign-Research → Test-Research-Valid → Test-Research-Tampered
  → Payload-Asset → Sign-Asset → Test-Asset-Valid → Test-Asset-Tampered
  → Payload-Publish → Sign-Publish → Test-Publish-Valid → Test-Publish-Tampered
  → Collect Results

  Save with Ctrl+S.
  </action>
  <verify>
  Workflow exists in n8n with the node chain described. At least 18 nodes visible.
  All "Continue on Fail" toggles are ON for HTTP Request nodes.
  </verify>
  <done>HMAC-Test-All-Functions workflow built and saved in n8n.</done>
</task>

<task type="auto">
  <name>Task 3: Execute test workflow and record results</name>
  <files>n8n UI, Supabase Edge Function logs</files>
  <action>
  Run HMAC-Test-All-Functions manually (click "Execute Workflow").

  After execution, check each HTTP Request node's output:

  For each Valid test node (Test-Topic-Valid, Test-Research-Valid, Test-Asset-Valid, Test-Publish-Valid):
  - Click the node in the execution view
  - Check "statusCode" field in the output JSON
  - Expected: 200 (or 201, 204 depending on function)
  - A 400 means the payload is malformed — go back to Task 1 and fix the payload
  - A 401 means the HMAC secret is wrong — recheck D:/n8n/.env vs Supabase secret
  - A 500 means the edge function itself has an error — check Supabase Function logs

  For each Tampered test node (Test-Topic-Tampered, etc.):
  - Expected: 401
  - If 200: HMAC validation is NOT working — stop and investigate edge function source
  - If 400: The function is rejecting the request before signature check — acceptable
  - If 500: Check Supabase Function logs

  INTERPRETING HTTP REQUEST RESPONSE IN N8N 2.9.0:
  When "Include Response Headers and Status" is enabled, the status code is at:
  $json.statusCode (or in the HTTP Response body as a nested field)
  If not visible in JSON output, look at the node's "Response" tab in execution details.

  Record results in this format:
  | Function                | Valid Signature | Tampered Signature |
  |-------------------------|-----------------|-------------------|
  | n8n-topic-callback      | 2xx / 4xx       | 401               |
  | n8n-research-callback   | 2xx / 4xx       | 401               |
  | n8n-asset-callback      | 2xx / 4xx       | 401               |
  | n8n-publish-callback    | 2xx / 4xx       | 401               |

  All 4 tampered tests MUST return 401 before this plan is considered complete.
  </action>
  <verify>
  All 4 tampered signature tests return HTTP 401.
  At minimum n8n-topic-callback returns 200 for a valid signature (others may return 400 if
  the test payload is incomplete — that is acceptable AS LONG AS tampered returns 401, not 200).
  </verify>
  <done>HMAC validation confirmed working on all 4 edge functions.</done>
</task>

<task type="auto">
  <name>Task 4: Export hmac-test.json to n8n-workflows/</name>
  <files>D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json</files>
  <action>
  Export HMAC-Test-All-Functions from n8n:
  - Three-dot menu → Download → Save as:
    D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json

  BEFORE committing to version control, sanitize the webhook secret from the exported JSON.
  Open the file and replace the actual 64-char hex secret with a placeholder:

  ```bash
  # Find and replace the secret value in the JSON
  # The secret appears in the "Set Secret and Base URL" node's parameters
  # Replace it with: REPLACE_WITH_N8N_WEBHOOK_SECRET

  python3 -c "
  import json, re, sys

  with open('D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json', 'r') as f:
      content = f.read()

  # Replace 64-char hex strings (the secret) with placeholder
  # Assumes secret is 64 lowercase hex chars
  content_sanitized = re.sub(r'[0-9a-f]{64}', 'REPLACE_WITH_N8N_WEBHOOK_SECRET', content)

  with open('D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json', 'w') as f:
      f.write(content_sanitized)

  print('Sanitized. Occurrences replaced:', content.count(re.findall(r'[0-9a-f]{64}', content)[0]) if re.findall(r'[0-9a-f]{64}', content) else 0)
  "
  ```

  Also replace the supabaseAnonKey if it appears in the JSON.

  Validate JSON is still valid after sanitization:
  ```bash
  python3 -c "import json; json.load(open('D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json')); print('Valid JSON')"
  ```
  </action>
  <verify>
  File exists at D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json
  File contains "n8n-topic-callback" string (function name)
  File does NOT contain the actual 64-char hex secret
  Python JSON parse succeeds
  </verify>
  <done>hmac-test.json exported, sanitized, and ready for version control.</done>
</task>

<task type="auto">
  <name>Task 5: Document canonical Code node pattern for Phase 4-6 reuse</name>
  <files>D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json (comments)</files>
  <action>
  The canonical HMAC Code node pattern is now validated. Confirm the following is true and
  ready to copy into every workflow in Phases 4-6 that calls an edge function:

  CANONICAL PATTERN (copy this block into Phase 4-6 workflows verbatim):

  ```
  PRE-REQUISITE: A Set node named "Set Secret" must appear before this Code node with:
    - field: webhookSecret = (value read from n8n credential or passed from workflow config)

  Code node: "Sign Payload for Supabase"
  ---
  const crypto = require('crypto');

  const secret = $('Set Secret').item.json.webhookSecret;
  const body = $input.item.json;
  const bodyString = JSON.stringify(body);
  const hmac = crypto.createHmac('sha256', secret);
  hmac.update(bodyString, 'utf8');
  const signature = 'sha256=' + hmac.digest('hex');

  return [{ json: { ...body, _signature: signature, _bodyString: bodyString } }];
  ---

  HTTP Request node after Code node:
  - Body: {{ $json._bodyString }}    (use _bodyString, NOT JSON.stringify($json) — avoid double-encode)
  - Header X-N8N-Signature: {{ $json._signature }}
  - Header Content-Type: application/json
  - Header apikey: <supabase anon key>
  ```

  Add this as a comment block at the top of hmac-test.json by wrapping the top-level JSON
  in a workflow description field (n8n supports a "description" field on workflow exports).

  In n8n UI, add this to the workflow description:
  - Open HMAC-Test-All-Functions
  - Click the workflow name → Edit description
  - Paste the canonical pattern as the description text
  - Save and re-export to overwrite hmac-test.json
  </action>
  <verify>
  hmac-test.json contains a "description" field with the canonical pattern text.
  grep -c "crypto.createHmac" "D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json"
  Must return > 0 (description text present in JSON).
  </verify>
  <done>Canonical pattern embedded in hmac-test.json description for Phase 4-6 reference.</done>
</task>
</tasks>

<verification>
Final verification checklist:

1. All 4 tampered tests returned 401:
   (Manual review of execution output in n8n — no automated command available)

2. hmac-test.json exists and is valid:
   python3 -c "import json; json.load(open('D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json')); print('OK')"

3. Secret is NOT in the JSON file:
   python3 -c "
   import json
   d = json.load(open('D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json'))
   text = json.dumps(d)
   # Check no 64-char hex string that is NOT the placeholder
   import re
   secrets = [m for m in re.findall(r'[0-9a-f]{64}', text) if m != 'REPLACE_WITH_N8N_WEBHOOK_SECRET'[:64]]
   print('Secrets found (should be 0):', len(secrets))
   "

4. n8n-topic-callback returns 200 for valid signature (manual check in execution view)

5. All 4 function names appear in the JSON:
   python3 -c "
   import json
   d = json.dumps(json.load(open('D:/Projects/fhcontent-creator-v2/n8n-workflows/hmac-test.json')))
   fns = ['n8n-topic-callback','n8n-research-callback','n8n-asset-callback','n8n-publish-callback']
   for fn in fns: print(fn, 'present:', fn in d)
   "
</verification>

<success_criteria>
- HMAC-Test-All-Functions workflow built and executed in n8n
- All 4 edge functions return 401 for tampered signatures
- At least n8n-topic-callback returns 200 for a valid signature
- Canonical Code node HMAC pattern confirmed working (from 03-01 spike, unchanged)
- hmac-test.json exported and sanitized (no live secrets)
- All 4 edge function names present in the exported JSON
- Results table (valid/tampered response codes) documented in 03-02-SUMMARY.md
</success_criteria>

<output>
After completion, create summary file:
D:/Projects/fhcontent-creator-v2/.planning/phases/03-webhook-security/03-02-SUMMARY.md

Include:
- Results table: function name, valid-signature response code, tampered-signature response code
- Any payload adjustments needed to get 200 responses (payload field names that were missing)
- Confirmation that the canonical Code node pattern (from 03-01) worked without modification
- Whether any function validated HMAC after body parsing (security concern — note if so)
- hmac-test.json file size and node count
</output>
