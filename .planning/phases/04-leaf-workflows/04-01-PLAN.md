---
phase: 04-leaf-workflows
plan: "04-01"
type: execute
wave: 1
depends_on:
  - "03-03"
files_modified:
  - n8n-workflows/wf5-status-poller.json
autonomous: true
requirements:
  - WF-05
  - INT-03
  - WF-06
  - INT-01

must_haves:
  truths:
    - "WF-5 fires every 10 minutes via Schedule Trigger"
    - "workflow_locks row prevents concurrent runs"
    - "All HTTP nodes carry X-Correlation-ID header set to content_piece_id"
    - "Execution is recorded in pipeline_runs on start and finish"
    - "n8n-asset-callback receives HMAC-signed POST for each status result"
  artifacts:
    - path: "n8n-workflows/wf5-status-poller.json"
      provides: "Exportable n8n workflow definition for WF-5"
      contains: "WF-5 Status Poller"
  key_links:
    - from: "WF-5 Schedule Trigger"
      to: "/api/cron/check-status"
      via: "HTTP Request node with CRON_SECRET header"
      pattern: "check-status"
    - from: "WF-5 result loop"
      to: "n8n-asset-callback Edge Function"
      via: "HMAC-signed HTTP POST"
      pattern: "n8n-asset-callback"
---

<objective>
Build WF-5 (Status Poller) in n8n. This workflow runs every 10 minutes, acquires a workflow lock, calls the existing Next.js /api/cron/check-status route, and writes status results back to Supabase via the n8n-asset-callback Edge Function. It replaces the Vercel 10-minute check-status cron job and establishes the sweeper pattern for async APIs (HeyGen, Blotato).
</objective>

<context>
@D:/Projects/fhcontent-creator-v2/.planning/ROADMAP.md
@D:/Projects/fhcontent-creator-v2/.planning/STATE.md
</context>

<tasks>
<task type="auto">
  <name>Task 1: Create WF-5 in n8n UI with Schedule Trigger</name>
  <files>n8n-workflows/wf5-status-poller.json</files>
  <action>
In the n8n UI at https://n8n.faithandharmonyllc.com:

1. Create new workflow named "WF-5 Status Poller".
2. Add **Schedule Trigger** node:
   - Trigger interval: Every 10 minutes
   - Node name: "Every 10 Minutes"

3. Add **Code** node named "Set Correlation Context":
```javascript
// N8N_BLOCK_ENV_ACCESS_IN_NODE=true — read secrets via input, not $env
const runId = $execution.id;
const startedAt = new Date().toISOString();
return [{
  json: {
    run_id: runId,
    workflow_id: 'WF-5',
    started_at: startedAt,
    lock_key: 'wf5-status-poller'
  }
}];
```

4. Add **HTTP Request** node named "Acquire Workflow Lock":
   - Method: POST
   - URL: `https://fhcontent-creator-v2.vercel.app/api/workflow-lock/acquire`
   - Authentication: Header Auth, Header Name: `x-cron-secret`, Credential: "Vercel Cron Secret"
   - Body (JSON):
```json
{
  "lock_key": "={{ $json.lock_key }}",
  "workflow_id": "={{ $json.workflow_id }}",
  "run_id": "={{ $json.run_id }}"
}
```
   - Response: store full response
   - On Error: Continue (error branch handled next)

5. Add **IF** node named "Lock Acquired?":
   - Condition: `{{ $json.acquired }}` equals `true`
   - True branch → Task 2
   - False branch → **No-Op Stop** (add a Code node that returns empty array: `return [];`)
  </action>
  <verify>Trigger manually. Confirm the Schedule Trigger fires. Confirm Lock Acquired IF node routes correctly when lock is free vs. already held.</verify>
  <done>WF-5 has Schedule Trigger → Set Correlation Context → Acquire Lock → Lock Acquired? branch.</done>
</task>

<task type="auto">
  <name>Task 2: Log execution start to pipeline_runs and call check-status</name>
  <files>n8n-workflows/wf5-status-poller.json</files>
  <action>
Continue from the TRUE branch of "Lock Acquired?":

1. Add **HTTP Request** node named "Log Run Start":
   - Method: POST
   - URL: `https://qjpujskwqaehxnqypxzu.supabase.co/rest/v1/pipeline_runs`
   - Authentication: Header Auth
     - `apikey`: Supabase Service Role key (credential: "Supabase Service Role")
     - `Authorization`: `Bearer <service_role_key>`
   - Headers: `Content-Type: application/json`, `Prefer: return=representation`
   - Body:
```json
{
  "workflow_id": "={{ $('Set Correlation Context').item.json.workflow_id }}",
  "run_id": "={{ $('Set Correlation Context').item.json.run_id }}",
  "status": "running",
  "started_at": "={{ $('Set Correlation Context').item.json.started_at }}"
}
```

2. Add **HTTP Request** node named "Call Check-Status Route":
   - Method: POST
   - URL: `https://fhcontent-creator-v2.vercel.app/api/cron/check-status`
   - Headers:
     - `Authorization`: `Bearer {{ $credentials["Vercel Cron Secret"].value }}`
     - `X-Correlation-ID`: `={{ $('Set Correlation Context').item.json.run_id }}`
     - `Content-Type`: `application/json`
   - Body: `{}`
   - Timeout: 55000ms (55 seconds, under Vercel's 60s function timeout)
   - On Error: Continue (captured in next step)

3. Add **Code** node named "Parse Check-Status Response":
```javascript
const response = $input.item.json;
const correlationId = $('Set Correlation Context').item.json.run_id;

// check-status returns array of updated content pieces
const pieces = Array.isArray(response.updated) ? response.updated : [];

return pieces.map(piece => ({
  json: {
    content_piece_id: piece.id,
    status: piece.status,
    platform: piece.platform,
    correlation_id: correlationId,
    checked_at: new Date().toISOString()
  }
}));
```
  </action>
  <verify>Run workflow with check-status cron active. Confirm pipeline_runs row inserted. Confirm Parse node emits one item per updated piece.</verify>
  <done>Log Run Start writes to pipeline_runs. Call Check-Status Route returns updated pieces. Parse node fans out to per-piece items. No TypeScript business logic is duplicated in n8n — all logic lives in the Next.js /api/cron/check-status route (INT-01).</done>
</task>

<task type="auto">
  <name>Task 3: Write back to n8n-asset-callback with HMAC signature</name>
  <files>n8n-workflows/wf5-status-poller.json</files>
  <action>
After "Parse Check-Status Response" (which may emit 0..N items):

1. Add **Code** node named "Build HMAC Signature":
```javascript
// Cannot use $env — secret injected via n8n credential expression
// Use a pre-shared value stored as n8n credential "N8N Signing Secret"
const secret = $credentials["N8N Signing Secret"].value;
const body = JSON.stringify($input.item.json);
const crypto = require('crypto');
const sig = crypto
  .createHmac('sha256', secret)
  .update(body)
  .digest('hex');

return [{
  json: {
    ...$input.item.json,
    _hmac: `sha256=${sig}`,
    _body: body
  }
}];
```

2. Add **HTTP Request** node named "POST to Asset Callback":
   - Method: POST
   - URL: `https://qjpujskwqaehxnqypxzu.supabase.co/functions/v1/n8n-asset-callback`
   - Headers:
     - `X-N8N-Signature`: `={{ $json._hmac }}`
     - `X-Correlation-ID`: `={{ $json.correlation_id }}`
     - `Content-Type`: `application/json`
     - `Authorization`: `Bearer {{ $credentials["Supabase Service Role"].value }}`
   - Body: `={{ $json._body }}`
   - On Error: Continue

3. Add **HTTP Request** node named "Release Workflow Lock":
   - Method: POST
   - URL: `https://fhcontent-creator-v2.vercel.app/api/workflow-lock/release`
   - Headers: `x-cron-secret`: Vercel Cron Secret credential
   - Body: `{ "lock_key": "wf5-status-poller" }`

4. Add **HTTP Request** node named "Log Run Complete":
   - Method: PATCH
   - URL: `https://qjpujskwqaehxnqypxzu.supabase.co/rest/v1/pipeline_runs?run_id=eq.={{ $('Set Correlation Context').item.json.run_id }}`
   - Headers: Supabase Service Role auth + `Prefer: return=minimal`
   - Body: `{ "status": "completed", "completed_at": "={{ new Date().toISOString() }}" }`

5. Connect error outputs of "Call Check-Status Route" and "POST to Asset Callback" to **WF-Error** workflow via **Execute Workflow** node:
   - Workflow: WF-Error (select by name)
   - Pass: `{ "error": "={{ $json.error }}", "workflow_id": "WF-5", "run_id": "={{ $('Set Correlation Context').item.json.run_id }}" }`
  </action>
  <verify>
1. Manually trigger WF-5 when check-status returns 2+ updated pieces.
2. Confirm n8n-asset-callback receives correctly signed POSTs (check Supabase Edge Function logs).
3. Confirm pipeline_runs row transitions running → completed.
4. Confirm lock released (second manual trigger should acquire lock successfully).
  </verify>
  <done>HMAC-signed callbacks posted to Edge Function. Lock released. pipeline_runs updated to completed.</done>
</task>

<task type="auto">
  <name>Task 4: Export workflow JSON</name>
  <files>n8n-workflows/wf5-status-poller.json</files>
  <action>
1. In n8n UI: WF-5 → ⋮ menu → Download.
2. Save file to `D:/Projects/fhcontent-creator-v2/n8n-workflows/wf5-status-poller.json`.
3. Confirm the JSON contains node names: "Every 10 Minutes", "Set Correlation Context", "Acquire Workflow Lock", "Lock Acquired?", "Log Run Start", "Call Check-Status Route", "Parse Check-Status Response", "Build HMAC Signature", "POST to Asset Callback", "Release Workflow Lock", "Log Run Complete".
  </action>
  <verify>File exists. `grep "WF-5 Status Poller" n8n-workflows/wf5-status-poller.json` returns match.</verify>
  <done>wf5-status-poller.json committed to repo.</done>
</task>
</tasks>

<verification>
1. n8n execution history shows WF-5 running every 10 minutes with status "succeeded".
2. pipeline_runs table has rows with workflow_id="WF-5" and status="completed".
3. Supabase Edge Function logs for n8n-asset-callback show 200 responses with valid HMAC signatures.
4. workflow_locks table shows no stale wf5-status-poller rows (lock acquired and released cleanly).
5. Vercel check-status cron still active (cutover happens in 04-04-PLAN.md).
</verification>

<success_criteria>
- WF-5 executes on 10-minute schedule without manual intervention.
- workflow_locks prevents concurrent runs (test by setting lock manually and confirming WF-5 skips).
- Every status update from check-status reaches n8n-asset-callback with valid X-N8N-Signature.
- pipeline_runs captures start and completion timestamps for every execution.
- No unhandled errors — all failures route to WF-Error.
</success_criteria>

<output>D:/Projects/fhcontent-creator-v2/n8n-workflows/wf5-status-poller.json</output>
