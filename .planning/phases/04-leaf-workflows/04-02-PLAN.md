---
phase: 04-leaf-workflows
plan: "04-02"
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - n8n-workflows/wf5-status-poller.json
autonomous: true
requirements:
  - ERR-04

must_haves:
  truths:
    - "All HTTP Request nodes in WF-5 retry up to 3 times with exponential backoff using the Code+Wait loop pattern"
    - "Retry waits: 2s after attempt 1, 4s after attempt 2, 8s after attempt 3 before permanent failure"
    - "429 and 5xx responses trigger retry; 4xx responses except 429 (e.g. 404, 400) fail immediately without retrying"
    - "After retry exhaustion the item is routed to WF-Error"
    - "wf5-status-poller.json reflects the hardened version"
  artifacts:
    - path: "n8n-workflows/wf5-status-poller.json"
      provides: "Retry-hardened WF-5 workflow definition"
      contains: "Retry Loop"
  key_links:
    - from: "HTTP Request error output"
      to: "Retry Counter Code node"
      via: "Loop back pattern with attempt counter in item.json"
      pattern: "attempt"
---

<objective>
Harden WF-5 by wrapping each HTTP Request node in an exponential backoff retry loop using the Code+Wait pattern (not built-in retry). Pattern: on 429 or 5xx, classify error as retryable, increment attempt counter, wait 2^attempt seconds (2s, 4s, 8s for attempts 1-3), then loop back to retry. 4xx errors except 429 are non-retryable and fail immediately. After 3 exhausted attempts, route to WF-Error. This satisfies ERR-04 and establishes the retry pattern reused in WF-2 and WF-4.
</objective>

<context>
@D:/Projects/fhcontent-creator-v2/.planning/ROADMAP.md
@D:/Projects/fhcontent-creator-v2/.planning/STATE.md
</context>

<tasks>
<task type="auto">
  <name>Task 2: Apply Code+Wait exponential loop to "Call Check-Status Route" node</name>
  <files>n8n-workflows/wf5-status-poller.json</files>
  <action>
**Retry sub-pattern reference** (apply this pattern to each HTTP node in this plan):

```
[HTTP Request node] ← loop-back connects here
    ↓ (error output)
[Code: Classify Error]
    ↓ retryable=true branch
[Code: Increment Attempt]
    ↓ attempt <= 3
[Wait node: 2^attempt seconds]
    ↓ (loops back to HTTP Request)
    ↓ attempt > 3 or retryable=false
[Execute Workflow: WF-Error]
```

**Code: Classify Error** logic (retryable = 429 or 5xx; all other 4xx including 404 = non-retryable):
```javascript
const statusCode = $input.item.json.statusCode || 0;
// 429 = rate limited (retryable), 5xx = server error (retryable)
// 4xx except 429 (e.g. 400 bad request, 404 not found) = non-retryable
const retryable = statusCode === 429 || statusCode >= 500;
const attempt = $input.item.json._attempt || 0;

return [{
  json: {
    ...$input.item.json,
    _retryable: retryable,
    _attempt: attempt
  }
}];
```

**Code: Increment Attempt** logic:
```javascript
const attempt = ($input.item.json._attempt || 0) + 1;
const waitSeconds = Math.pow(2, attempt); // 2, 4, 8

return [{
  json: {
    ...$input.item.json,
    _attempt: attempt,
    _wait_seconds: waitSeconds,
    _exhausted: attempt > 3
  }
}];
```

**IF: Retryable?** condition: `{{ $json._retryable }}` equals `true`
- True → Increment Attempt node
- False → Execute Workflow: WF-Error (pass workflow_id, run_id, error)

**IF: Exhausted?** condition: `{{ $json._exhausted }}` equals `true`
- True → Execute Workflow: WF-Error
- False → Wait node

**Wait node** configuration:
- Wait amount: `={{ $json._wait_seconds }}`
- Unit: Seconds
- Resume: After wait (not webhook-based)
- Connects back to the HTTP Request node input (forming the loop)

In n8n UI, apply this pattern to "Call Check-Status Route":

1. Set "Call Check-Status Route" HTTP Request node **On Error**: Output to a separate branch.
2. Connect the error output to: Code "Classify Error - Check-Status" → IF "Retryable? - Check-Status" → Code "Increment Attempt - Check-Status" → IF "Exhausted? - Check-Status" → Wait "Backoff - Check-Status" → loop back to "Call Check-Status Route".
3. Non-retryable branch of "Retryable?" and exhausted branch of "Exhausted?" both route to Execute Workflow: WF-Error.
4. The success output of "Call Check-Status Route" continues to "Parse Check-Status Response" as before.

Note: n8n does not support visual cycles. Model the loop-back using a **Loop Over Items** node wrapping the HTTP call with max iterations: 4 (initial + 3 retries). Inside the loop: HTTP Request → IF success → Break; IF error → Classify → IF retryable → Wait → continue; else Break to WF-Error path.
  </action>
  <verify>
1. Simulate a 500 response by temporarily pointing "Call Check-Status Route" URL to `https://httpstat.us/500`.
2. Manually trigger WF-5. Confirm the loop retries 3 times with increasing delays (observe timestamps in n8n execution log: ~2s, ~4s, ~8s gaps).
3. Confirm execution routes to WF-Error after 3 exhausted attempts.
4. Simulate a 404: confirm workflow fails immediately without retrying (non-retryable).
5. Restore URL to `https://fhcontent-creator-v2.vercel.app/api/cron/check-status`.
  </verify>
  <done>Call Check-Status Route retries up to 3 times with 2s/4s/8s exponential backoff on 429/5xx. 404 and other 4xx errors fail immediately without retrying.</done>
</task>

<task type="auto">
  <name>Task 3: Apply exponential loop to remaining HTTP nodes and test all retry paths</name>
  <files>n8n-workflows/wf5-status-poller.json</files>
  <action>
Apply the same Code+Wait exponential loop pattern (defined in Task 2) to all remaining HTTP Request nodes in WF-5:

1. **"Log Run Start"** (Supabase REST POST):
   - On Error → Classify Error - Log Start → IF Retryable? → Increment Attempt → IF Exhausted? → WF-Error / Wait → loop back
   - Same 3-attempt, exponential wait logic

2. **"POST to Asset Callback"** (Edge Function POST):
   - On Error → Classify Error - Asset Callback → IF Retryable? → Increment Attempt → IF Exhausted? → route to pipeline_errors DLQ insert (not WF-Error, since partial success is possible):
```javascript
// DLQ insert for undeliverable callback
return [{
  json: {
    workflow_id: 'WF-5',
    content_piece_id: $input.item.json.content_piece_id,
    error_type: 'callback_failure',
    error_message: $input.item.json.error?.message || 'Asset callback failed after 3 retries',
    payload: JSON.stringify($input.item.json),
    created_at: new Date().toISOString()
  }
}];
```
   Then HTTP Request to `https://qjpujskwqaehxnqypxzu.supabase.co/rest/v1/pipeline_errors` (POST, Supabase auth).

3. **"Release Workflow Lock"** (POST to /api/workflow-lock/release):
   - On Error → Classify Error - Lock Release → IF Retryable? → Increment Attempt with max 5 attempts → Wait → loop back
   - Critical: must release. Increase `_exhausted` threshold to `attempt > 5` for this node only.

4. **"Log Run Complete"** (Supabase REST PATCH):
   - On Error → Classify Error - Log Complete → standard 3-attempt exponential loop → WF-Error on exhaustion

**End-to-end retry simulation test** (run after applying all loops):
- Test 500 on each major node (Check-Status, Asset Callback) and confirm 3-retry exponential behavior.
- Test 429 on "Call Check-Status Route" — confirm retries with correct delays.
- Test 404 on "Call Check-Status Route" — confirm immediate non-retryable failure.
- Test 500 on "Release Workflow Lock" — confirm 5 retry attempts before exhaustion.
- Restore all URLs after testing.
- Document test results in WF-5 workflow description field in n8n UI.
  </action>
  <verify>
1. Open each HTTP node in WF-5 — confirm no built-in "Retry On Fail" settings; retry is handled by the Code+Wait loop.
2. n8n execution log shows exponential timing gaps (2s, 4s, 8s) during simulated error tests.
3. pipeline_errors receives a row when "POST to Asset Callback" exhausts retries.
4. "Release Workflow Lock" exhausts at 5 attempts (not 3).
5. WF-5 runs cleanly end-to-end after URLs restored.
  </verify>
  <done>All HTTP nodes in WF-5 use Code+Wait exponential loop. Lock release retries 5 times. 4xx non-retryable behavior explicit in all Classify Error nodes.</done>
</task>

<task type="auto">
  <name>Task 4: Export updated workflow JSON</name>
  <files>n8n-workflows/wf5-status-poller.json</files>
  <action>
1. In n8n UI: WF-5 → Download → overwrite `D:/Projects/fhcontent-creator-v2/n8n-workflows/wf5-status-poller.json`.
2. Confirm JSON contains "Classify Error" node names and "Backoff" Wait nodes (evidence of Code+Wait pattern).
3. Confirm JSON does NOT contain `"retryOnFail": true` in HTTP Request node parameters (built-in retry must not be used).
  </action>
  <verify>
- `grep -c "Classify Error" n8n-workflows/wf5-status-poller.json` returns 4 or more.
- `grep "retryOnFail" n8n-workflows/wf5-status-poller.json` returns no matches.
  </verify>
  <done>Hardened wf5-status-poller.json with Code+Wait exponential loops saved to repo.</done>
</task>
</tasks>

<verification>
1. All HTTP Request nodes in WF-5 use Code+Wait exponential loops (no built-in retry).
2. Simulated 500 error causes 3 retry attempts with 2s/4s/8s waits before final failure.
3. Simulated 429 causes same retry behavior as 500.
4. Simulated 404 fails immediately without retrying (non-retryable 4xx).
5. pipeline_errors receives a row when asset callback fails after exhausted retries.
6. Lock release node retries 5 times before exhaustion.
7. wf5-status-poller.json updated and contains Classify Error nodes, not retryOnFail flags.
</verification>

<success_criteria>
- Zero unhandled HTTP errors in WF-5 under normal transient failure conditions.
- Code+Wait exponential loop pattern documented and ready to apply to WF-2 and WF-4.
- Retryable vs non-retryable error classification is explicit: 429 + 5xx = retry; other 4xx = fail immediately.
- pipeline_errors captures permanently failed callbacks.
- All HTTP nodes use explicit Code+Wait loop (no implicit built-in retry defaults relied upon).
</success_criteria>

<output>D:/Projects/fhcontent-creator-v2/n8n-workflows/wf5-status-poller.json</output>
